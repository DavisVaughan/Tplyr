
#' Custom assertions
#'
#' @description
#' These assertions abstract away common checks required throughout package development. Furthermore, the provide detailed and
#' explicit messages to the user that direct them to the source of the error without having to search through the trace back
#' to find culprit function call.
#'
#' @param x Object to be inspected
#' @param should_be The expected class of the object
#'
#' @details
#' When generating the error, these assertions capture the input arguments name, and capture the the calling functions name
#' from the call stack. This information is then reported within the error message generated by \code{rlang::abort} and the trace back
#' is triggered so the user has the necessary information to review
#'
#' @family Custom Assertions
#' @rdname custom_assertions
#' @export
#'
#' @examples
#' \dontrun{
#' fun1 <- function(my_param) {
#'   assert_has_class(my_param, 'character')
#' }
#'
#' fun1(1)
#' #>  Error: Argument `my_param` in function `fun1` must be character. Instead a class of "numeric" was passed.
#'
#' fun2 <- function(my_param) {
#'   assert_inherits_class(my_param, 'numeric')
#' }
#'
#' fun2(tibble::tibble(a=c(1,2,3)))
#' #>  Error: Argument `my_param` in function `fun2` does not inherit numeric. Classes: tbl_df, tbl, data.frame
#' }
assert_has_class <- function(x, should_be) {
  # Get the name of the parameter being checked
  param <- quo_get_expr(enquo(x))

  # Is the argument the class that it shoudl be?
  if (class(x) != should_be){
    # Grab the trace back into an object
    trc <- trace_back()
    # Look at the length of the traceback
    max_length <- max(trc$indices)
    # If it's >1 we're innside a function, so grab the name
    if (max_length > 1){
      # Pull the name out of the call stack
      cname <- call_name(trc$calls[[max_length - 1]])
      # Make a display string
      func_str <- paste0('` in function `', cname, '`')
    } else {
      # Filler
      func_str <- '`'
    }
    # Abort and show error
    abort(paste0('Argument `', param, func_str, ' must be ',
                 should_be, '. Instead a class of "', class(x),
                 '" was passed.'))
  }
}

#' Assert that an argument inherits certain class
#'
#' @param x Object to be inspected
#' @param should_have Expected class that object should inherit
#'
#' @export
#' @family Custom Assertions
#' @rdname custom_assertions
assert_inherits_class <- function(x, should_have) {
  # Get the name of the parameter being checked
  param <- quo_get_expr(enquo(x))

  # Is the argument the class that it should be?
  if (!inherits(x, should_have)){

    # Grab the trace back into an object
    trc <- trace_back()
    # Look at the length of the traceback
    max_length <- max(trc$indices)
    # If it's >1 we're innside a function, so grab the name
    if (max_length > 1){
      # Pull the name out of the call stack
      cname <- call_name(trc$calls[[max_length - 1]])
      # Make a display string
      func_str <- paste0('` in function `', cname, '`')
    } else {
      # Filler
      func_str <- '`'
    }
    # Abort and show error
    abort(paste0('Argument `', param, func_str,
                 ' does not inherit "', should_have,
                 '". Classes: ', paste(class(x), collapse=", ")))
  }
}
