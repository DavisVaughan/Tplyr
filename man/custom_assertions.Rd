% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/assertions.R
\name{assert_has_class}
\alias{assert_has_class}
\alias{assert_inherits_class}
\alias{assert_quo_var_present}
\alias{unpack_vars}
\alias{is_null_or_call}
\title{Custom assertions}
\usage{
assert_has_class(x, should_be)

assert_inherits_class(x, should_have)

assert_quo_var_present(
  quo_list,
  vnames = NULL,
  envir = NULL,
  allow_character = TRUE
)

unpack_vars(quo_list, allow_character = TRUE)

is_null_or_call(quo_var)
}
\arguments{
\item{x}{Object to be inspected}

\item{should_be}{The expected class of the object}

\item{should_have}{Expected class that object should inherit}

\item{quo_list}{A variable that can be a string, variable, or combination of
those using dplyr::vars}

\item{vnames}{Variable names of the target dataset to check against}

\item{envir}{Environment containing the dataset \code{target} from which names will be checked against}

\item{allow_character}{Whether or not character strings are allows in an entry}

\item{quo_var}{A quosure object to check}
}
\value{
Returns nothing, raises errors when assertations aren't met

Unpacked quosure.
}
\description{
These assertions abstract away common checks required throughout package development. Furthermore, the provide detailed and
explicit messages to the user that direct them to the source of the error without having to search through the trace back
to find culprit function call.
}
\details{
When generating the error, these assertions capture the input arguments name, and capture the the calling functions name
from the call stack. This information is then reported within the error message generated by \code{rlang::abort} and the trace back
is triggered so the user has the necessary information to review
}
\examples{
\dontrun{
fun1 <- function(my_param) {
  assert_has_class(my_param, 'character')
}

fun1(1)
#>  Error: Argument `my_param` in function `fun1` must be character. Instead a class of
#>  "numeric" was passed.

fun2 <- function(my_param) {
  assert_inherits_class(my_param, 'numeric')
}

fun2(tibble::tibble(a=c(1,2,3)))
#>  Error: Argument `my_param` in function `fun2` does not inherit numeric.
#>  Classes: tbl_df, tbl, data.frame
}
}
\concept{Custom Assertions}
